#pragma once
//SJCLib
#include <SJCLib.h>
//Local
#include "Definitions.h"

namespace BISLibrary
{
	enum EvalChar
	{
		CHAR_ILLEGAL,
		CHAR_NULLBYTE,
		CHAR_TABSPACE,
		CHAR_LINEFEED,
		CHAR_CARRIAGERETURN,
		CHAR_NEGATION,
		CHAR_INVERTEDCOMMA,
		CHAR_NUMBERSIGN,
		CHAR_AND,
		CHAR_BRACKETOPEN,
		CHAR_BRACKETCLOSE,
		SQS_CC_MULTIPLY,
		CHAR_PLUS,
		CHAR_COMMA,
		CHAR_MINUS,
		CHAR_DOT,
		SQS_CC_SLASH,
		CHAR_NUMBER,
		CHAR_COLON,
		CHAR_SEMICOLON,
		CC_LESSTHAN,
		CHAR_ASSIGNMENT,
		CHAR_GREATERTHAN,
		CHAR_QUESTIONMARK,
		CHAR_AT,
		CHAR_LETTER,
		CHAR_SQUAREDBRACKETOPEN,
		CHAR_SQUAREDBRACKETCLOSE,
		CHAR_UNDERLINE,
		CHAR_BRACEOPEN,
		CHAR_OR,
		CHAR_BRACECLOSE,
		CHAR_TILDE,
		CHAR_INVALID
	};

	enum TokenState
	{
		STATE_ILLEGAL,
		STATE_START,
		STATE_END,
		STATE_TABSPACE,
		STATE_CARRIAGERETURN,
		STATE_LINEFEED,
		STATE_NEGATION,
		STATE_EQUALS,
		STATE_NOTEQUALS,
		STATE_UNCLOSEDLITERAL,
		STATE_CLOSEDLITERAL,
		STATE_UNCLOSEDBRACELITERAL,
		STATE_CLOSEDBRACELITERAL,
		STATE_NUMBERSIGN,
		STATE_WAITFORTIME,
		SQS_STATE_LOGICALAND,
		STATE_LABEL,
		STATE_BRACKETOPEN,
		STATE_BRACKETCLOSE,
		SQS_STATE_MULTIPLY,
		STATE_PLUS,
		STATE_COMMA,
		STATE_MINUS,
		SQS_STATE_SLASH,
		STATE_NUMBER,
		STATE_UNFINISHEDFLOAT,
		STATE_FLOAT,
		STATE_COLON,
		STATE_SEMICOLON,
		SQS_STATE_LESSTHAN,
		SQS_STATE_LESSOREQUAL,
		STATE_ASSIGNMENT,
		STATE_GREATERTHAN,
		SQS_STATE_GREATEROREQUAL,
		STATE_QUESTIONMARK,
		STATE_AT,
		STATE_LETTER,
		STATE_SQUAREDBRACKETOPEN,
		STATE_SQUAREDBRACKETCLOSE,
		STATE_UNDERLINE,
		STATE_BRACEOPEN,
		STATE_OR,
		STATE_BRACECLOSE,
		STATE_LOGICALOR,
		STATE_TILDE,
		STATE_PRIVATEVARIABLE,
		STATE_INVALID,
		STATE_FINISHED
	};

	enum Token
	{
		TOKEN_ILLEGAL,
		TOKEN_END,
		TOKEN_INVALID,
		TOKEN_TABSPACE,
		TOKEN_ASSIGNMENT,
		SQS_TOKEN_LESSTHAN,
		SQS_TOKEN_LESSOREQUAL,
		TOKEN_GREATERTHAN,
		SQS_TOKEN_GREATEROREQUAL,
		TOKEN_QUESTIONMARK,
		TOKEN_WAITFORCONDITION,
		TOKEN_CARRIAGERETURN,
		TOKEN_LINEFEED,
		TOKEN_NEGATION,
		TOKEN_EQUALS,
		TOKEN_NOTEQUALS,
		TOKEN_LITERAL,
		TOKEN_WAITFORTIME,
		SQS_TOKEN_LOGICALAND,
		TOKEN_LABEL,
		TOKEN_BRACKETOPEN,
		TOKEN_BRACKETCLOSE,
		SQS_TOKEN_MULTIPLY,
		TOKEN_PLUS,
		SQS_TOKEN_MINUS,
		SQS_TOKEN_SLASH,
		TOKEN_COMMA,
		TOKEN_INT,
		TOKEN_FLOAT,
		TOKEN_COLON,
		TOKEN_SEMICOLON,
		TOKEN_COMMENT,
		TOKEN_IDENTIFIER,
		TOKEN_SQUAREDBRACKETOPEN,
		TOKEN_SQUAREDBRACKETCLOSE,
		TOKEN_BRACEOPEN,
		TOKEN_BRACECLOSE,
		TOKEN_LOGICALOR,
		TOKEN_DELAY,
		TOKEN_PRIVATEVARIABLE,
		TOKEN_THIS
	};

	static Token GetKeywordToken(SJCLib::CString &tokenValue)
	{
		return TOKEN_IDENTIFIER;
	}

	class SJCBISLIB_API CSQSLexer
	{
	private:
		//Variables
		SJCLib::CString tokenValue;
		const char *pSourceStart;
		char *pSource;
		//Functions
		EvalChar EvaluateChar(char c);
		Token GetTokenType(TokenState state);
		TokenState NextState(TokenState state, EvalChar c);
	public:
		//Constructor
		CSQSLexer();
		//Destructor
		~CSQSLexer();
		//Functions
		SJCLib::CString GetCurrentTokenValue();
		void Init(const char *pSource);
		uint32 GetCurrentOffset();
		Token GetNextToken(bool ignore = true);
	};
}